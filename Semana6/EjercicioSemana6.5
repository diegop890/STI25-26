/*
 * Sistema con:
 *  - Lectura ADC
 *  - Tarea LED (PWM)
 *  - Tarea Impresora (solo imprime cambios > 10 CAD)
 *  - Tarea Alarma (detecta Rsensor fuera de rango)
 */

#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "esp_adc/adc_oneshot.h"
#include "driver/ledc.h"

// CONSTANTES HARDWARE
#define PIN_SENSOR       36
#define MASK_SENSOR      (1ULL << PIN_SENSOR)
#define CHANNEL_ADC      ADC_CHANNEL_0

#define ADC_MAX          512
#define VREF             3.3f
#define R1_FIXED         10000.0f   // 10k superior
#define ANGULO_MAX       180.0f

// RANGOS DE ALARMA
#define RSENSOR_MIN      100.0f
#define RSENSOR_MAX      900.0f

// PWM
#define PWM_FREC         4000
#define PWM_RES          10
#define PIN_LED          22

static const char* TAG = "MyModule";

// PROTOTIPOS
void tareaSensor(void *arg);
void tareaLED(void *arg);
void tareaImpresora(void *arg);
void tareaAlarma(void *arg);

// HANDLES
adc_oneshot_unit_handle_t h_adc;
QueueHandle_t colaCAD_LED;
QueueHandle_t colaANG_IMP;
QueueHandle_t colaALARMAS;

void app_main(void)
{
    // COLAS
    colaCAD_LED  = xQueueCreate(1, sizeof(int));
    colaANG_IMP  = xQueueCreate(1, sizeof(float));
    colaALARMAS  = xQueueCreate(1, sizeof(float));   // Rsensor fuera de rango

    // TAREAS
    xTaskCreate(tareaSensor,     "tareaSensor",     4096, NULL, 1, NULL);
    xTaskCreate(tareaLED,        "tareaLED",        2048, NULL, 1, NULL);
    xTaskCreate(tareaImpresora,  "tareaImpresora",  2048, NULL, 1, NULL);
    xTaskCreate(tareaAlarma,     "tareaAlarma",     2048, NULL, 1, NULL);

    while(1)
        vTaskDelay(pdMS_TO_TICKS(5000));
}

void tareaSensor(void *arg)
{
    adc_oneshot_unit_init_cfg_t adc_cfg = {
        .clk_src = ADC_RTC_CLK_SRC_DEFAULT,
        .ulp_mode = ADC_ULP_MODE_DISABLE,
        .unit_id = ADC_UNIT_1
    };
    adc_oneshot_new_unit(&adc_cfg, &h_adc);

    adc_oneshot_chan_cfg_t chan_cfg = {
        .atten = ADC_ATTEN_DB_0,
        .bitwidth = ADC_BITWIDTH_9
    };
    adc_oneshot_config_channel(h_adc, CHANNEL_ADC, &chan_cfg);

    int valorCAD;
    float volt, Rsensor, angulo;

    while(1)
    {
        adc_oneshot_read(h_adc, CHANNEL_ADC, &valorCAD);

        volt = (valorCAD * VREF) / ADC_MAX;
        Rsensor = (volt * R1_FIXED) / (VREF - volt);
        angulo = (volt / VREF) * ANGULO_MAX;

        // Enviar datos a las tareas correspondientes
        xQueueSend(colaCAD_LED, &valorCAD, 0);
        xQueueSend(colaANG_IMP, &angulo, 0);

        // ---- DETECCIÓN DE ALARMA ----
        if (Rsensor < RSENSOR_MIN || Rsensor > RSENSOR_MAX)
        {
            xQueueSend(colaALARMAS, &Rsensor, 0);
        }

        vTaskDelay(pdMS_TO_TICKS(200));
    }
}

void tareaLED(void *arg)
{
    ledc_timer_config_t timer_cfg = {
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_num = LEDC_TIMER_0,
        .freq_hz = PWM_FREC,
        .duty_resolution = PWM_RES,
        .clk_cfg = LEDC_USE_RC_FAST_CLK
    };
    ledc_timer_config(&timer_cfg);

    ledc_channel_config_t ch_cfg = {
        .channel = LEDC_CHANNEL_0,
        .gpio_num = PIN_LED,
        .duty = 0,
        .hpoint = 0,
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_sel = LEDC_TIMER_0
    };
    ledc_channel_config(&ch_cfg);

    int cad;

    while(1)
    {
        xQueueReceive(colaCAD_LED, &cad, portMAX_DELAY);
        int duty = cad * 2;
        ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
        ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
    }
}

void tareaImpresora(void *arg)
{
    float angulo;
    float ultimoAng = -1000;
    float difMin = (10.0f * ANGULO_MAX) / ADC_MAX;  // equivalente a 10 CAD

    while(1)
    {
        xQueueReceive(colaANG_IMP, &angulo, portMAX_DELAY);

        if (fabs(angulo - ultimoAng) >= difMin)
        {
            ESP_LOGI(TAG, "Ángulo = %.2f grados", angulo);
            ultimoAng = angulo;
        }
    }
}

void tareaAlarma(void *arg)
{
    float Rsensor;
    int contadorErrores = 0;

    while(1)
    {
        // Espera bloqueada
        xQueueReceive(colaALARMAS, &Rsensor, portMAX_DELAY);

        // Imprimir aviso de alarma
        ESP_LOGW(TAG, "RSensor fuera de rango: %.2f ohm", Rsensor);
        contadorErrores++;

        // Cada 10 errores → alarma crítica
        if (contadorErrores >= 10)
        {
            ESP_LOGE(TAG, "¡¡¡10 ERRORES DETECTADOS — REVISAR EQUIPO!!!");
            contadorErrores = 0;   // reiniciamos
        }
    }
}
