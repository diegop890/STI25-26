/*
 * Lectura ADC ESP32 con:
 * - Tarea de sensor (ADC)
 * - Tarea de LED (PWM)
 * - Tarea de impresión (solo imprime si el valor cambia más de 10 CAD)
 */

#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "esp_adc/adc_oneshot.h"
#include "driver/ledc.h"

// CONSTANTES HARDWARE
#define PIN_SENSOR       36
#define MASK_SENSOR      (1ULL << PIN_SENSOR)
#define CHANNEL_ADC      ADC_CHANNEL_0

#define ADC_MAX          512
#define VREF             3.3f
#define R1_FIXED         10000.0f   // 10k
#define R_SENSOR_MAX     1000.0f    // 1k
#define ANGULO_MAX       180.0f

// PWM
#define PWM_FREC         4000
#define PWM_RES          10
#define PIN_LED          22
#define MASK_LED         (1ULL << PIN_LED)

static const char* TAG = "MyModule";

// PROTOTIPOS
void tareaSensor(void *arg);
void tareaLED(void *arg);
void tareaImpresora(void *arg);

// HANDLES
adc_oneshot_unit_handle_t h_adc;
QueueHandle_t colaCAD_LED;
QueueHandle_t colaANG_IMP;


void app_main(void)
{
    // creación de colas
    colaCAD_LED = xQueueCreate(1, sizeof(int));    // CAD hacia LED
    colaANG_IMP = xQueueCreate(1, sizeof(float));  // ángulo hacia impresora

    // creación de tareas
    xTaskCreate(tareaSensor, "tareaSensor", 4096, NULL, 1, NULL);
    xTaskCreate(tareaLED, "tareaLED", 2048, NULL, 1, NULL);
    xTaskCreate(tareaImpresora, "tareaImpresora", 2048, NULL, 1, NULL);

    while(1)
    {
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}


// ====================================================================
// TAREA SENSOR (ADC)
// ====================================================================
void tareaSensor(void *arg)
{
    gpio_config_t cfg = {
        .intr_type = GPIO_INTR_DISABLE,
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .pin_bit_mask = MASK_SENSOR
    };
    gpio_config(&cfg);

    adc_oneshot_unit_init_cfg_t adc_cfg = {
        .clk_src = ADC_RTC_CLK_SRC_DEFAULT,
        .ulp_mode = ADC_ULP_MODE_DISABLE,
        .unit_id = ADC_UNIT_1
    };
    adc_oneshot_new_unit(&adc_cfg, &h_adc);

    adc_oneshot_chan_cfg_t chan_cfg = {
        .atten = ADC_ATTEN_DB_0,
        .bitwidth = ADC_BITWIDTH_9
    };
    adc_oneshot_config_channel(h_adc, CHANNEL_ADC, &chan_cfg);

    int valorCAD;
    float angulo;

    while(1)
    {
        adc_oneshot_read(h_adc, CHANNEL_ADC, &valorCAD);

        float volt = (valorCAD * VREF) / ADC_MAX;
        float Rsensor = (volt * R1_FIXED) / (VREF - volt);
        angulo = (volt / VREF) * ANGULO_MAX;

        // Enviar CAD a LED
        xQueueSend(colaCAD_LED, &valorCAD, 0);

        // Enviar ángulo a impresora
        xQueueSend(colaANG_IMP, &angulo, 0);

        // NOTA: NO SE IMPRIME NADA AQUÍ
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}


// ====================================================================
// TAREA LED (PWM)
// ====================================================================
void tareaLED(void *arg)
{
    ledc_timer_config_t timer_cfg = {
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_num = LEDC_TIMER_0,
        .freq_hz = PWM_FREC,
        .duty_resolution = PWM_RES,
        .clk_cfg = LEDC_USE_RC_FAST_CLK
    };
    ledc_timer_config(&timer_cfg);

    ledc_channel_config_t ch_cfg = {
        .channel = LEDC_CHANNEL_0,
        .gpio_num = PIN_LED,
        .duty = 0,
        .hpoint = 0,
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_sel = LEDC_TIMER_0
    };
    ledc_channel_config(&ch_cfg);

    int cad;

    while(1)
    {
        xQueueReceive(colaCAD_LED, &cad, portMAX_DELAY);
        int duty = cad * 2;
        ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
        ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
    }
}


// ====================================================================
// TAREA IMPRESORA
// ====================================================================
void tareaImpresora(void *arg)
{
    float angulo;
    float ultimoAng = -1000;   // iniciar con un valor imposible
    const float diferenciaCAD = (10.0f * ANGULO_MAX) / ADC_MAX;

    while(1)
    {
        // Espera bloqueada
        xQueueReceive(colaANG_IMP, &angulo, portMAX_DELAY);

        // SOLO IMPRIME SI CAMBIÓ MÁS DE 10 VALORES DE CAD
        if (fabs(angulo - ultimoAng) >= diferenciaCAD)
        {
            ESP_LOGI(TAG, "Ángulo = %.2f grados", angulo);
            ultimoAng = angulo;
        }
    }
}
