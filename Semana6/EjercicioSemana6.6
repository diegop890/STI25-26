/*
 * Sistema con:
 *  - Lectura ADC
 *  - Tarea LED dependiente de CAD (PWM)
 *  - Tarea Impresora (solo imprime cambios > 10 CAD)
 *  - Tarea Alarma (Rsensor fuera de rango)
 *  - Tarea PWMControl (nuevos niveles 0,1/3,2/3,1 cada 4s)
 */

#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "esp_adc/adc_oneshot.h"
#include "driver/ledc.h"

// CONSTANTES HARDWARE
#define PIN_SENSOR       36
#define CHANNEL_ADC      ADC_CHANNEL_0
#define ADC_MAX          512
#define VREF             3.3f
#define R1_FIXED         10000.0f
#define ANGULO_MAX       180.0f

// RANGOS ALARMA
#define RSENSOR_MIN      100.0f
#define RSENSOR_MAX      900.0f

// PWM LED (controlado por CAD)
#define PIN_LED          22
#define PWM_RES          10
#define PWM_FREC         4000

// PWM NUEVO PARA CONTROL (nuevo requisito)
#define PIN_PWM_CTRL     23      // puedes cambiarlo
#define PWM_CTRL_TIMER   LEDC_TIMER_1
#define PWM_CTRL_CH      LEDC_CHANNEL_1
#define PWM_CTRL_RES     10
#define PWM_CTRL_FREQ    5000

static const char* TAG = "MyModule";

// PROTOTIPOS
void tareaSensor(void *arg);
void tareaLED(void *arg);
void tareaImpresora(void *arg);
void tareaAlarma(void *arg);
void tareaPWMControl(void *arg);

// HANDLES
adc_oneshot_unit_handle_t h_adc;
QueueHandle_t colaCAD_LED;
QueueHandle_t colaANG_IMP;
QueueHandle_t colaALARMAS;

void app_main(void)
{
    // COLAS
    colaCAD_LED  = xQueueCreate(1, sizeof(int));
    colaANG_IMP  = xQueueCreate(1, sizeof(float));
    colaALARMAS  = xQueueCreate(1, sizeof(float));

    // TAREAS
    xTaskCreate(tareaSensor,      "tareaSensor",      4096, NULL, 1, NULL);
    xTaskCreate(tareaLED,         "tareaLED",         2048, NULL, 1, NULL);
    xTaskCreate(tareaImpresora,   "tareaImpresora",   2048, NULL, 1, NULL);
    xTaskCreate(tareaAlarma,      "tareaAlarma",      2048, NULL, 1, NULL);
    xTaskCreate(tareaPWMControl,  "tareaPWMControl",  2048, NULL, 1, NULL);

    while(1)
        vTaskDelay(pdMS_TO_TICKS(5000));
}

void tareaSensor(void *arg)
{
    adc_oneshot_unit_init_cfg_t adc_cfg = {
        .clk_src = ADC_RTC_CLK_SRC_DEFAULT,
        .ulp_mode = ADC_ULP_MODE_DISABLE,
        .unit_id = ADC_UNIT_1
    };
    adc_oneshot_new_unit(&adc_cfg, &h_adc);

    adc_oneshot_chan_cfg_t chan_cfg = {
        .atten = ADC_ATTEN_DB_0,
        .bitwidth = ADC_BITWIDTH_9
    };
    adc_oneshot_config_channel(h_adc, CHANNEL_ADC, &chan_cfg);

    int valorCAD;
    float volt, Rsensor, angulo;

    while(1)
    {
        adc_oneshot_read(h_adc, CHANNEL_ADC, &valorCAD);

        volt = (valorCAD * VREF) / ADC_MAX;
        Rsensor = (volt * R1_FIXED) / (VREF - volt);
        angulo = (volt / VREF) * ANGULO_MAX;

        xQueueSend(colaCAD_LED, &valorCAD, 0);
        xQueueSend(colaANG_IMP, &angulo, 0);

        // Enviar alarma
        if (Rsensor < RSENSOR_MIN || Rsensor > RSENSOR_MAX)
            xQueueSend(colaALARMAS, &Rsensor, 0);

        vTaskDelay(pdMS_TO_TICKS(200));
    }
}

void tareaLED(void *arg)
{
    ledc_timer_config_t timer_cfg = {
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_num = LEDC_TIMER_0,
        .freq_hz = PWM_FREC,
        .duty_resolution = PWM_RES,
        .clk_cfg = LEDC_USE_RC_FAST_CLK
    };
    ledc_timer_config(&timer_cfg);

    ledc_channel_config_t ch_cfg = {
        .channel = LEDC_CHANNEL_0,
        .gpio_num = PIN_LED,
        .duty = 0,
        .hpoint = 0,
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_sel = LEDC_TIMER_0
    };
    ledc_channel_config(&ch_cfg);

    int cad;

    while(1)
    {
        xQueueReceive(colaCAD_LED, &cad, portMAX_DELAY);
        int duty = cad * 2;
        ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
        ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
    }
}

void tareaImpresora(void *arg)
{
    float angulo;
    float ultimo = -999;
    float difMin = (10.0f * ANGULO_MAX) / ADC_MAX;

    while(1)
    {
        xQueueReceive(colaANG_IMP, &angulo, portMAX_DELAY);

        if (fabs(angulo - ultimo) >= difMin)
        {
            ESP_LOGI(TAG, "Ángulo = %.2f grados", angulo);
            ultimo = angulo;
        }
    }
}

void tareaAlarma(void *arg)
{
    float Rsensor;
    int contador = 0;

    while(1)
    {
        xQueueReceive(colaALARMAS, &Rsensor, portMAX_DELAY);

        ESP_LOGW(TAG, "ALERTA: Rsensor fuera de rango = %.2f ohm", Rsensor);
        contador++;

        if (contador >= 10)
        {
            ESP_LOGE(TAG, "¡¡¡10 ERRORES — REVISAR EQUIPO!!!");
            contador = 0;
        }
    }
}

void tareaPWMControl(void *arg)
{
    // Configurar temporizador
    ledc_timer_config_t timer_cfg = {
        .speed_mode       = LEDC_LOW_SPEED_MODE,
        .timer_num        = PWM_CTRL_TIMER,
        .freq_hz          = PWM_CTRL_FREQ,
        .duty_resolution  = PWM_CTRL_RES,
        .clk_cfg          = LEDC_USE_RC_FAST_CLK
    };
    ledc_timer_config(&timer_cfg);

    // Canal PWM
    ledc_channel_config_t ch_cfg = {
        .channel    = PWM_CTRL_CH,
        .gpio_num   = PIN_PWM_CTRL,
        .duty       = 0,
        .hpoint     = 0,
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_sel  = PWM_CTRL_TIMER
    };
    ledc_channel_config(&ch_cfg);

    // Niveles de potencia
    int dutyMax = (1 << PWM_CTRL_RES) - 1;
    int dutyLevels[4] = {
        0,
        dutyMax / 3,
        (2 * dutyMax) / 3,
        dutyMax
    };

    int index = 0;

    while(1)
    {
        int duty = dutyLevels[index];
        ledc_set_duty(LEDC_LOW_SPEED_MODE, PWM_CTRL_CH, duty);
        ledc_update_duty(LEDC_LOW_SPEED_MODE, PWM_CTRL_CH);

        ESP_LOGI(TAG, "PWMControl → Potencia %.0f %%", (duty * 100.0f) / dutyMax);

        index = (index + 1) % 4;
        vTaskDelay(pdMS_TO_TICKS(4000));
    }
}
